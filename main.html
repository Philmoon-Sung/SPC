<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Prompt Generator for SUNO AI (Layout Enhanced)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        ::-webkit-scrollbar { width: 6px; height: 6px; } /* Scrollbar width slightly reduced */
        ::-webkit-scrollbar-track { background: #1e293b; border-radius: 3px; } /* bg-slate-800 */
        ::-webkit-scrollbar-thumb { background-color: #475569; border-radius: 3px; border: 1px solid #1e293b; } /* bg-slate-600 */
        ::-webkit-scrollbar-thumb:hover { background-color: #64748b; } /* bg-slate-500 */
        body { font-family: 'Inter', sans-serif; scrollbar-width: thin; scrollbar-color: #475569 #1e293b; }
        .placeholder-text-custom { color: #94a3b8; font-style: italic; } /* text-slate-400 */
        .btn-single-select.selected { background-color: #6366f1 !important; color: white !important; }
        .btn-multi-select.selected { background-color: #8b5cf6 !important; color: white !important; }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 200px; background-color: #334155; color: #fff; text-align: center; border-radius: 6px; padding: 5px 8px; position: absolute; z-index: 50; bottom: 125%; left: 50%; margin-left: -100px; opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; box-shadow: 0 2px 5px rgba(0,0,0,0.2); line-height: 1.4; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 100; border-radius: 0.375rem; }
        .loading-overlay.hidden { display: none; }
        .spinner { border: 3px solid #e2e8f0; border-top: 3px solid #8b5cf6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Custom smaller text for options panel if needed beyond text-xs */
        .text-xxs { font-size: 0.65rem; line-height: 0.9rem; }
    </style>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontSize: {
              'xxs': '0.65rem', // For very small text if text-xs is not enough
            },
            colors: {
              'brand-primary': '#4f46e5', 'brand-secondary': '#7c3aed', 
              'dark-bg': '#0f172a', /* slate-900 */
              'dark-card': '#1e293b', /* slate-800 */
              'dark-input': '#334155', /* slate-700 */
              'dark-input-focus': '#475569', /* slate-600 */
              'dark-text': '#cbd5e1', /* slate-300 */
              'dark-text-muted': '#94a3b8', /* slate-400 */
            },
            fontFamily: { sans: ['Inter', 'sans-serif'], },
          }
        }
      }
    </script>
</head>
<body class="bg-dark-bg text-dark-text min-h-screen flex flex-col items-center justify-center p-2 overflow-hidden">

<div class="container bg-dark-card/80 backdrop-blur-md shadow-2xl rounded-xl p-2 md:p-4 w-full max-w-screen-2xl flex flex-col h-[97vh] overflow-hidden">
    <div class="sticky-header-controls bg-dark-card/90 p-2 md:p-3 rounded-t-lg shadow-md flex-shrink-0 z-20">
        <div class="header flex flex-col sm:flex-row justify-between items-center gap-2 mb-2">
            <div class="header-buttons-left flex gap-1.5">
                <button id="undo-button" title="실행 취소" class="px-2.5 py-1 text-xs bg-slate-600 hover:bg-slate-500 rounded shadow transition-colors flex items-center gap-1 disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-undo"></i> Undo</button>
                <button id="reset-button" title="전체 초기화" class="px-2.5 py-1 text-xs bg-red-600 hover:bg-red-500 rounded shadow transition-colors flex items-center gap-1"><i class="fas fa-sync-alt"></i> Reset</button>
            </div>
            <h1 class="text-lg sm:text-xl md:text-2xl font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500 order-first sm:order-none">LLM Prompt Generator for SUNO</h1>
            <div class="header-buttons-right flex gap-1.5">
                 <button id="home-button" title="메인 페이지로 이동 (구현 필요)" class="px-2.5 py-1 text-xs bg-slate-600 hover:bg-slate-500 rounded shadow transition-colors flex items-center gap-1"><i class="fas fa-home"></i> Home</button>
            </div>
        </div>
        <div class="preset-controls flex flex-col sm:flex-row items-center gap-1.5 sm:gap-2 py-1.5 border-t border-slate-700">
            <button id="save-preset-button" class="preset-button px-2.5 py-1 text-xs bg-green-600 hover:bg-green-500 rounded shadow transition-colors w-full sm:w-auto flex items-center justify-center gap-1"><i class="fas fa-save"></i> Save Preset As...</button>
            <input type="text" id="preset-name-input" placeholder="프리셋 파일 이름" class="flex-grow px-2 py-1 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none w-full sm:w-auto">
            <button id="load-preset-file-button" class="preset-button px-2.5 py-1 text-xs bg-blue-600 hover:bg-blue-500 rounded shadow transition-colors w-full sm:w-auto flex items-center justify-center gap-1"><i class="fas fa-folder-open"></i> Load Preset</button>
            <input type="file" id="load-preset-file-input" accept=".json" class="hidden">
        </div>
        <div class="api-key-controls mt-1.5 pt-1.5 border-t border-slate-700 flex flex-col sm:flex-row items-center gap-1.5">
            <label for="api-key-input" class="text-xs font-medium text-dark-text-muted whitespace-nowrap">Gemini API Key:</label>
            <input type="password" id="api-key-input" placeholder="Enter API Key" class="flex-grow px-2 py-1 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none w-full sm:w-auto">
            <button id="save-api-key-button" title="API 키 저장" class="px-2.5 py-1 text-xs bg-orange-600 hover:bg-orange-500 rounded shadow transition-colors flex items-center gap-1"><i class="fas fa-key"></i> Save</button>
             <span class="tooltip ml-0.5"><i class="fas fa-exclamation-triangle text-yellow-400 text-xs"></i><span class="tooltiptext">API 키는 브라우저의 localStorage에 저장됩니다. 공용PC 주의.</span></span>
        </div>
    </div>

    <div class="main-content flex flex-col lg:flex-row gap-2 md:gap-3 flex-grow overflow-hidden mt-2 md:mt-3">
        <div class="options-column lg:w-1/2 p-1.5 md:p-2 overflow-y-auto rounded-lg bg-dark-card/50 min-h-0 border border-slate-700/50">
            <div class="prompt-builder-section mb-3 p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="core-vibe">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-lightbulb text-sm"></i> Core Idea & Vibe</h2>
                <div class="prompt-section mb-2">
                    <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-main-theme-group">Theme (주제)</label>
                    <div id="lyrics-main-theme-group" class="input-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div>
                </div>
                <div class="prompt-section mb-2">
                    <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="unified-mood-section-content">Mood / Vibe (분위기/감성)</label>
                    <div id="unified-mood-section-content" class="input-container vertical-stack space-y-1.5 p-1.5 bg-slate-700/40 rounded" data-section-ref="unified">
                        <span class="subsection-label text-xxs text-slate-500">Select Mood/Vibe Terms (Optional):</span>
                        <div id="unified-mood-options" class="options-group flex flex-wrap gap-1"></div>
                        <span class="subsection-label text-xxs text-slate-500 mt-1">Describe Mood/Emotion in Detail (한글 서술):</span>
                        <textarea id="unified-mood-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none resize-none" rows="2" placeholder="노래의 전반적인 느낌이나 감정을 한글로 자유롭게 서술"></textarea>
                    </div>
                </div>
            </div>

            <div class="prompt-builder-section mb-3 p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="lyrical-details">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-feather-alt text-sm"></i> Lyrical Content & Structure</h2>
                <div class="space-y-2">
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-story-persona-input">Story / Situation</label> <textarea id="lyrics-story-persona-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none resize-none" rows="2" placeholder="주인공(화자), 상황, 배경 스토리"></textarea> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-imagery-input">Imagery / Keywords</label> <textarea id="lyrics-imagery-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none resize-none" rows="2" placeholder="장면, 사물, 단어, 감각 표현 등"></textarea> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-message-input">Target / Message</label> <textarea id="lyrics-message-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none resize-none" rows="2" placeholder="핵심 메시지, 듣는 이에게 남길 감정"></textarea> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-tone-options">Linguistic Tone</label> <div id="lyrics-tone-options" class="input-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                    <div class="prompt-section">
                        <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-reference-song-input">Reference Song Title (가사 스타일 참고)
                            <span class="tooltip ml-0.5"><i class="fas fa-info-circle text-slate-500 text-xxs"></i><span class="tooltiptext">특정 곡의 가사 스타일(어투, 주제, 감성 등)을 참고하고 싶을 때 입력.</span></span>
                        </label>
                        <input type="text" id="lyrics-reference-song-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none" placeholder="예: 아이유 - 밤편지">
                    </div>
                </div>
                 <div class="prompt-section mt-2"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="lyrics-songform-section-content">Song Form</label>
                    <div id="lyrics-songform-section-content" class="input-container sequence-builder-content space-y-1.5 p-1.5 bg-slate-700/40 rounded" data-section-ref="lyrics">
                        <div class="flex items-center gap-1"><span class="text-xxs text-slate-500">Click elements to add:</span></div>
                        <div id="lyrics-songform-elements" class="sequence-elements flex flex-wrap gap-1"></div>
                        <div id="lyrics-selected-songform-container" class="selected-sequence-container min-h-[30px] bg-slate-600/60 p-1.5 rounded flex flex-wrap gap-1 items-center"><span class="placeholder-text-custom text-xxs">Click elements above...</span></div>
                        <div class="songform-controls flex gap-1 mt-1">
                            <button id="songform-remove-last" class="px-1.5 py-0.5 text-xxs bg-yellow-600 hover:bg-yellow-500 rounded shadow flex items-center gap-0.5"><i class="fas fa-undo-alt"></i> Remove Last</button>
                            <button id="songform-clear-all" class="px-1.5 py-0.5 text-xxs bg-red-600 hover:bg-red-500 rounded shadow flex items-center gap-0.5"><i class="fas fa-trash-alt"></i> Clear All</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="prompt-builder-section mb-3 p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="musical-foundation">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-guitar text-sm"></i> Musical Foundation</h2>
                <div class="prompt-section mb-2"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-genre-options">Genre <span class="text-xxs text-slate-500">(Multi)</span></label> <div id="style-genre-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                <div class="prompt-section mb-2"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-time-signature-options">Time Signature</label> <div id="style-time-signature-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                <div class="prompt-section mb-2">
                    <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-tempo-options-container">Tempo / Energy</label>
                    <div id="style-tempo-options-container" class="options-container multi-level space-y-1.5 p-1.5 bg-slate-700/40 rounded" data-section-ref="style">
                        <div id="style-tempo-control-container" class="flex flex-col sm:flex-row items-start sm:items-center gap-1.5">
                            <div id="style-tempo-buttons-group" class="options-group flex flex-wrap gap-1"></div>
                            <div id="style-bpm-input-container" class="flex items-center gap-1">
                                <label for="style-bpm-input" class="text-xxs text-slate-500 whitespace-nowrap">BPM:</label>
                                <input type="number" id="style-bpm-input" class="text-input-field w-16 p-1 text-xs text-center bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none" min="30" max="300" placeholder="e.g. 120">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="prompt-section mb-2">
                    <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block">Era / Sound <span class="text-xxs text-slate-500">(Multi)</span></label>
                    <div id="style-era-sound-container" class="options-container vertical-stack space-y-1.5 p-1.5 bg-slate-700/40 rounded" data-section-ref="style">
                        <div> <span class="subsection-label text-xxs text-slate-500">Select Era:</span> <div id="style-era-options-era" class="options-group flex flex-wrap gap-1 mt-0.5"></div> </div>
                        <div> <span class="subsection-label text-xxs text-slate-500 mt-1">Select Sound Features:</span> <div id="style-era-options-features" class="options-group flex flex-wrap gap-1 mt-0.5"></div> </div>
                    </div>
                </div>
            </div>

            <div class="prompt-builder-section mb-3 p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="instrumentation-sound">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-drum text-sm"></i> Instrumentation & Sound</h2>
                <div class="prompt-section mb-2"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-instrument-options">Instrument <span class="text-xxs text-slate-500">(Multi)</span></label> <div id="style-instrument-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
            </div>

            <div class="prompt-builder-section mb-3 p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="vocal-characteristics">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-microphone-alt text-sm"></i> Vocal Definition</h2>
                <div class="space-y-2">
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-vocal-options">Vocal Style <span class="text-xxs text-slate-500">(Multi)</span></label> <div id="style-vocal-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-vocal-age-options">Vocal Age</label> <div id="style-vocal-age-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-tone-options">Vocal Tone <span class="text-xxs text-slate-500">(Multi)</span></label> <div id="style-tone-options" class="options-container options-group flex flex-wrap gap-1 p-1.5 bg-slate-700/40 rounded"></div> </div>
                </div>
                 <div class="prompt-section mt-2"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-detailed-requests-input">Detailed Requests</label>
                    <textarea id="style-detailed-requests-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none resize-none" rows="2" placeholder="음악 스타일, 곡 진행, 악기 연주, 보컬 표현 등"></textarea>
                </div>
            </div>

            <div class="prompt-builder-section p-2 bg-slate-700/20 rounded-md shadow-sm" data-group="influences-exclusions">
                <h2 class="text-base font-semibold text-purple-400 border-b border-slate-700 pb-1.5 mb-2 flex items-center gap-1.5"><i class="fas fa-user-friends text-sm"></i> Influences & Exclusions</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-artist-input">Artist Style (음악 스타일 참고)</label> <input type="text" id="style-artist-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none" placeholder="e.g., Michael Jackson"> </div>
                    <div class="prompt-section"> <label class="section-label text-xs font-medium text-dark-text-muted mb-0.5 block" for="style-negative-prompts-input">Exclude</label> <input type="text" id="style-negative-prompts-input" class="text-input-field w-full p-1.5 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-purple-500 outline-none" placeholder="e.g., drums, saxophone"> <span class="helper-text text-xxs text-slate-500 mt-0.5">쉼표(,)로 구분</span> </div>
                </div>
            </div>
        </div>

        <div class="right-main-column lg:w-1/2 flex flex-col lg:flex-row gap-2 md:gap-3 overflow-hidden min-h-0">
            <div class="right-left-subcolumn lg:w-1/2 flex flex-col gap-2 md:gap-3 min-h-0">
                <div class="prompt-output-section flex flex-col bg-dark-card/50 rounded-lg shadow p-2 md:p-3 overflow-hidden flex-1 min-h-[200px] lg:min-h-[calc(50vh-3rem)] relative border border-slate-700/50">
                     <label class="output-label text-sm font-semibold text-purple-300 mb-1.5 block" for="llm-prompt-output">LLM Instruction Prompt</label>
                     <div class="relative flex-grow min-h-0">
                        <div id="llm-prompt-output" class="generated-prompt-display h-full bg-slate-700/60 border border-slate-600 rounded p-2 text-xs leading-relaxed overflow-y-auto whitespace-pre-wrap break-words font-mono">Select options...</div>
                     </div>
                     <div class="text-right text-xxs text-dark-text-muted mt-1" id="style-char-count-display">Style: 0 / 500 chars</div>
                     <div class="footer-buttons flex flex-col sm:flex-row justify-end gap-1.5 mt-2 flex-shrink-0">
                         <button id="generate-with-api-button" class="action-button px-2.5 py-1 text-xs bg-violet-600 hover:bg-violet-500 rounded shadow transition-colors flex items-center justify-center gap-1">
                            <i class="fas fa-cogs"></i> Generate with API
                         </button>
                         <button id="copy-llm-prompt-button" class="action-button px-2.5 py-1 text-xs bg-sky-600 hover:bg-sky-500 rounded shadow transition-colors flex items-center justify-center gap-1">
                            <i class="fas fa-copy"></i> Copy Prompt
                         </button>
                     </div>
                     <div id="api-loading-overlay" class="loading-overlay hidden"><div class="spinner"></div></div>
                 </div>
            </div>

            <div class="right-right-subcolumn lg:w-1/2 flex flex-col gap-2 md:gap-3 min-h-0">
                <div class="generated-lyrics-section flex flex-col bg-dark-card/50 rounded-lg shadow p-2 md:p-3 overflow-hidden flex-1 min-h-[200px] lg:min-h-[calc(50vh-3rem)] border border-slate-700/50">
                    <div class="flex justify-between items-center mb-1.5">
                        <label class="text-sm font-semibold text-green-400 block" for="generated-lyrics-output">Generated Lyrics (Editable)</label>
                        <button id="copy-lyrics-button" title="가사 복사" class="px-2 py-0.5 text-xxs bg-green-600 hover:bg-green-500 rounded shadow transition-colors flex items-center gap-1"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                    <textarea id="generated-lyrics-output" class="w-full h-full p-2 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-green-500 outline-none resize-none font-mono" placeholder="Lyrics will appear here..."></textarea>
                </div>
                <div class="generated-style-section flex flex-col bg-dark-card/50 rounded-lg shadow p-2 md:p-3 overflow-hidden flex-1 min-h-[150px] lg:min-h-[calc(30vh-3rem)] border border-slate-700/50">
                     <div class="flex justify-between items-center mb-1.5">
                        <label class="text-sm font-semibold text-blue-400 block" for="generated-style-output">Generated Style Desc (Editable)</label>
                        <button id="copy-style-button" title="스타일 설명 복사" class="px-2 py-0.5 text-xxs bg-blue-600 hover:bg-blue-500 rounded shadow transition-colors flex items-center gap-1"><i class="fas fa-copy"></i> Copy</button>
                    </div>
                    <textarea id="generated-style-output" class="w-full h-full p-2 text-xs bg-dark-input border border-dark-input-focus rounded focus:ring-1 focus:ring-blue-500 outline-none resize-none font-mono" placeholder="Style description will appear here..."></textarea>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- INTEGRATED JAVASCRIPT (v3.0.6 - Major Layout & Font Adjustments) ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing LLM Prompt Generator (v3.0.6 - Major Layout & Font Adjustments)...");

        const GEMINI_API_KEY_STORAGE_KEY = 'geminiApiKey';
        // --- Data Definitions (Korean translations updated) ---
        const lyricsData = {
            themes: { "사랑": [], "일상": [], "꿈": [], "사회": [], "자연": [], "감사": [], "행복": [], "가족": [], "광고": [], "찬양": [] },
            tones: [ "Pleading (애원하는)", "Objective (객관적)", "Confessional (고백하는)", "Observational / Calm (관조적/담담함)", "Earnest (간절한)", "Cynical / Sarcastic (냉소적/반어적)", "Firm (단호한)", "Plain (담백함)", "Witty (위트있는)", "Comforting (위로하는)", "Humorous (유머러스)", "Passionate (열정적)", "Sincere (진솔함)", "Direct / Blunt (직설적)", "Poetic (시적)", "Lyrical (서정적)", "Declarative (선언적인)", "Storytelling (스토리텔링)", "Warm (따뜻한)", "Richly Appealing (호소력 짙은)" ],
            songFormElements: ['[Intro]', '[Verse]', '[Pre-Chorus]', '[Chorus]', '[Verse 2]', '[Chorus 2]', '[Bridge]', '[Rap Verse]', '[Outro]', '[Interlude]', '[Hook]', '[Solo]', '[Instrumental Break]', '[Ad-lib]']
        };
        const styleData = {
             genres: [ "Acoustic (어쿠스틱)", "Alternative Rock (얼터너티브 록)", "Ambient (앰비언트)", "Blues (블루스)", "Bossa Nova (보사노바)", "Chillwave (칠웨이브)", "Cinematic (시네마틱)", "Classical (클래식)", "Country (컨트리)", "Dance Pop (댄스 팝)", "Disco (디스코)", "Dream Pop (드림 팝)", "Drum and Bass (드럼 앤 베이스)", "Dubstep (덥스텝)", "EDM (이디엠)", "Electronic (일렉트로닉)", "Folk (포크)", "Funk (펑크)", "Gospel (가스펠)", "Hard Rock (하드 록)", "HipHop (힙합)", "House (하우스)", "Indie Folk (인디 포크)", "Indie Pop (인디 팝)", "Indie Rock (인디 록)", "Jazz (재즈)", "J-Pop (제이팝)", "K-Indie (케이 인디)", "K-Pop (케이팝)", "K-Pop Ballad (케이팝 발라드)", "Korean Ballad (한국 발라드)", "Korean Trot (한국 트로트)", "Latin (라틴)", "Lo-fi (로파이)", "Metal (메탈)", "Orchestral (오케스트라)", "Pop (팝)", "Pop Rock (팝 록)", "Progressive Rock (프로그레시브 록)", "Punk Rock (펑크 록)", "R&B (알앤비)", "Reggae (레게)", "Rock (록)", "Shoegaze (슈게이징)", "Soul (소울)", "Synth-Pop (신스팝)", "Synthwave (신스웨이브)", "Techno (테크노)", "Trance (트랜스)", "Trap (트랩)", "World Music (월드 뮤직)", "Worldbeat (월드비트)" ],
             timeSignatures: [ "4/4", "3/4", "6/8", "2/2", "Free Time (자유 박자)" ],
             instruments: ["808 Drums (808 드럼)","Accordion (아코디언)","Acoustic Guitar (어쿠스틱 기타)","Bagpipes (백파이프)","Banjo (밴조)","Bass Guitar (베이스 기타)","Bells (종)","Bongo Drums (봉고 드럼)","Brass (브라스)","Cello (첼로)","Choir (합창)","Clarinet (클라리넷)","Clavinet (클라비넷)","Conga Drums (콩가 드럼)","Didgeridoo (디저리두)","Double Bass (더블 베이스)","Drums (드럼)","Drum Machine (드럼 머신)","Duduk (두둑)","Electric Guitar (일렉트릭 기타)","Distorted Electric Guitar (디스토션 기타)","Electric Piano (일렉트릭 피아노)","Fiddle (피들)","Flute (플루트)","French Horn (프렌치 호른)","Glockenspiel (글로켄슈필)","Gong (공)","Hammond Organ (해먼드 오르간)","Harmonica (하모니카)","Harp (하프)","Harpsichord (하프시코드)","Kalimba (칼림바)","Lute (류트)","Mandolin (만돌린)","Marimba (마림바)","Melodica (멜로디카)","Moog Synthesizer (무그 신디사이저)","Oboe (오보에)","Organ (오르간)","Pan Flute (팬 플루트)","Percussion (퍼커션)","Piano (피아노)","Piccolo (피콜로)","Recorder (리코더)","Saxophone (색소폰)","Sitar (시타르)","Steel Drums (스틸 드럼)","Strings (스트링)","Synthesizer (신디사이저)","Tabla (타블라)","Tambourine (탬버린)","Theremin (테레민)","Timpani (팀파니)","Triangle (트라이앵글)","Trombone (트롬본)","Trumpet (트럼펫)","Tuba (튜바)","Ukulele (우쿨렐레)","Vibraphone (비브라폰)","Viola (비올라)","Violin (바이올린)","Whistle (휘슬)","Xylophone (실로폰)","Zither (치터)"],
             moods: [ "Aggressive (공격적인)", "Bright (밝은)", "Calm (차분한)", "Chill (느긋한)", "Dark (어두운)", "Dramatic (극적인)", "Dreamy (몽환적인)", "Eerie (으스스한)", "Energetic (활기찬)", "Epic (웅장한)", "Exciting (신나는)", "Groovy (흥겨운)", "Happy (행복한)", "Hopeful (희망찬)", "Intense (강렬한)", "Lonely (외로운)", "Majestic (장엄한)", "Melancholic (우울한)", "Mysterious (신비로운)", "Nostalgic (향수 어린)", "Passionate (격정적인)", "Peaceful (평화로운)", "Playful (장난기 있는)", "Relaxing (편안한)", "Romantic (낭만적인)", "Sad (슬픈)", "Sentimental (감상적인)", "Serene (고요한)", "Smooth (부드러운)", "Tense (긴장감 있는)", "Uplifting (희망을 주는)", "Upbeat (업비트)" ],
             tempos: [ "Very Slow (매우 느리게)", "Slow (느리게)", "Medium-Slow (중간보다 느리게)", "Medium (보통)", "Medium-Fast (중간보다 빠르게)", "Fast (빠르게)", "Very Fast (매우 빠르게)", "Uptempo (업템포)", "Downtempo (다운템포)" ],
             eraFeatures: [ "Pre-50s (50년대 이전)", "50s (50년대)", "60s (60년대)", "70s (70년대)", "80s (80년대)", "90s (90년대)", "2000s (2000년대)", "2010s (2010년대)", "Modern (현대적)", "Futuristic (미래적)", "Ambient (앰비언트)", "Atmospheric (분위기 있는)", "Clean Production (깔끔한 프로덕션)", "Experimental (실험적인)", "Glitchy (글리치한)", "Granular (그래뉼러)", "Lo-fi Production (로파이 프로덕션)", "Minimal (미니멀)", "Psychedelic (사이키델릭)", "Raw Sound (거친 사운드)", "Retro (레트로)", "Vintage (빈티지)", "Wall of Sound (사운드의 벽)" ],
             vocals: [ "Male Vocal (남성 보컬)", "Female Vocal (여성 보컬)", "Child Vocal (어린이 보컬)", "Androgynous Vocal (중성적 보컬)", "Duet (듀엣)", "Harmony Vocals (하모니 보컬)", "Group Vocals (그룹 보컬)", "Choir (합창)", "Rap (랩)", "Spoken Word (스포큰 워드)", "Whispering Vocal (속삭이는 보컬)", "Screaming Vocal (스크리밍 보컬)", "Growling Vocal (그로울링 보컬)", "Operatic Vocal (오페라 보컬)", "Vocoder (보코더)", "Autotuned Vocal (오토튠 보컬)", "Narration (나레이션)" ],
             vocalAges: ["Child (어린이)", "Teenager (10대)", "Young Adult (20대 초중반)", "Adult (20대 후반-30대)", "Middle-Aged (40-50대)", "Senior (60대 이상)"],
             vocalTones: ["Airy (공기감 있는)","Angelic (천사 같은)","Breathy (숨소리 섞인)","Bright (밝은 톤)","Clear Diction (정확한 발음)","Clear (명료한)","Commanding (단호한)","Crisp (청량한)","Deep (깊은 톤)","Delicate (섬세한)","Edgy (날카로운)","Ethereal (천상의)","Gentle (부드러운)","Gravelly (자갈 같은)","Gritty (거친 느낌)","Growling (으르렁거리는)","Harsh (거친)","Haunting (잊혀지지 않는)","Heartfelt (진심 어린)","Hoarse (쉰)","Husky (허스키한)","Melancholic Tone (우울한 톤)","Melodious (듣기 좋은)","Monotone (단조로운)","Muffled (먹먹한)","Nasal (비음 섞인)","Operatic (오페라틱)","Piercing (꿰뚫는 듯한)","Powerful (힘 있는)","Raspy (쉰 목소리)","Resonant (울림 있는)","Rich (풍부한)","Robotic (로봇 같은)","Rough (거친 톤)","Seductive Tone (유혹적인 톤)","Sharp (날카로운 톤)","Silky (비단결 같은)","Smoky (연기 같은)","Smooth Tone (부드러운 톤)","Soft (부드러운 톤)","Soulful (소울풀한)","Strained (긴장된)","Strong (강한 톤)","Sweet Tone (달콤한 톤)","Thin (얇은 톤)","Trembling (떨리는)","Velvety (벨벳 같은)","Vulnerable Tone (취약한 톤)","Warm (따뜻한)"]
        };

        let appState = {
            apiKey: '', 
            unifiedMoodSelection: [], unifiedMoodInput: '',
            lyrics: { theme: null, storyPersonaInput: '', imageryInput: '', messageInput: '', tone: [], referenceSongInput: '', selectedSongForm: [], generatedLyrics: '' },
            style: { genres: [], timeSignature: null, instruments: [], tempo: null, bpm: null, eraFeatures: [], vocals: [], vocalAge: null, vocalTones: [], detailedVocalRequests: '', artist: '', negativePrompts: '', generatedStyleDescription: '', bpmInputValue: '', artistInputValue: '', negativePromptsValue: '' }
        };
        let history = [];
        let isProcessingUndo = false;
        const unifiedMoodCategory = 'unifiedMood';

        const domRefs = {
            undoButton: document.getElementById('undo-button'),resetButton: document.getElementById('reset-button'),homeButton: document.getElementById('home-button'),
            savePresetButton: document.getElementById('save-preset-button'),presetNameInput: document.getElementById('preset-name-input'),
            loadPresetFileButton: document.getElementById('load-preset-file-button'),loadPresetFileInput: document.getElementById('load-preset-file-input'),
            apiKeyInput: document.getElementById('api-key-input'), saveApiKeyButton: document.getElementById('save-api-key-button'),
            lyricsMainThemeGroup: document.getElementById('lyrics-main-theme-group'),
            unifiedMoodOptionsContainer: document.getElementById('unified-mood-options'),unifiedMoodInputArea: document.getElementById('unified-mood-input'),
            lyricsStoryPersonaInput: document.getElementById('lyrics-story-persona-input'),lyricsImageryInput: document.getElementById('lyrics-imagery-input'),
            lyricsMessageInput: document.getElementById('lyrics-message-input'),lyricsToneOptions: document.getElementById('lyrics-tone-options'),
            lyricsReferenceSongInput: document.getElementById('lyrics-reference-song-input'), 
            lyricsSongformElementsContainer: document.getElementById('lyrics-songform-elements'),lyricsSelectedSongformContainer: document.getElementById('lyrics-selected-songform-container'),
            songformRemoveLastButton: document.getElementById('songform-remove-last'),songformClearAllButton: document.getElementById('songform-clear-all'),
            styleGenreOptions: document.getElementById('style-genre-options'),styleTimeSignatureOptions: document.getElementById('style-time-signature-options'),
            styleTempoButtonsGroup: document.getElementById('style-tempo-buttons-group'),styleBpmInput: document.getElementById('style-bpm-input'),
            styleEraOptionsEra: document.getElementById('style-era-options-era'),styleEraOptionsFeatures: document.getElementById('style-era-options-features'),
            styleInstrumentOptions: document.getElementById('style-instrument-options'),
            styleVocalOptions: document.getElementById('style-vocal-options'),styleVocalAgeOptions: document.getElementById('style-vocal-age-options'),
            styleToneOptions: document.getElementById('style-tone-options'), styleDetailedRequestsInput: document.getElementById('style-detailed-requests-input'),
            styleArtistInput: document.getElementById('style-artist-input'),styleNegativePromptsInput: document.getElementById('style-negative-prompts-input'),
            llmPromptOutput: document.getElementById('llm-prompt-output'),styleCharCountDisplay: document.getElementById('style-char-count-display'),
            generateWithApiButton: document.getElementById('generate-with-api-button'), apiLoadingOverlay: document.getElementById('api-loading-overlay'),
            copyLlmPromptButton: document.getElementById('copy-llm-prompt-button'),
            generatedLyricsOutput: document.getElementById('generated-lyrics-output'), copyLyricsButton: document.getElementById('copy-lyrics-button'),
            generatedStyleOutput: document.getElementById('generated-style-output'), copyStyleButton: document.getElementById('copy-style-button'),
        };

        function getEnglishPart(text) { if (typeof text !== 'string') return ''; const match = text.match(/^(.*?)\s*\(/); return match ? match[1].trim() : text.trim(); }
        function getKoreanPart(text) { if (typeof text !== 'string') return ''; const match = text.match(/\((.*?)\)/); return match ? match[1].trim() : ''; }
        function sortByEnglish(a, b) { return getEnglishPart(a).toLowerCase().localeCompare(getEnglishPart(b).toLowerCase()); }
        function sortByKorean(a, b) { return getKoreanPart(a).localeCompare(getKoreanPart(b), 'ko'); }
        function deepClone(obj) { try { return JSON.parse(JSON.stringify(obj)); } catch (e) { console.error("Deep clone failed:", e); if (typeof structuredClone === 'function') return structuredClone(obj); return null; } }

        function getCurrentAppStateForSave() {
            let currentState = deepClone(appState);
            if (!currentState) return null;
            currentState.apiKey = domRefs.apiKeyInput?.value || '';
            currentState.unifiedMoodInput = domRefs.unifiedMoodInputArea?.value.trim() || '';
            currentState.lyrics.storyPersonaInput = domRefs.lyricsStoryPersonaInput?.value.trim() || '';
            currentState.lyrics.imageryInput = domRefs.lyricsImageryInput?.value.trim() || '';
            currentState.lyrics.messageInput = domRefs.lyricsMessageInput?.value.trim() || '';
            currentState.lyrics.referenceSongInput = domRefs.lyricsReferenceSongInput?.value.trim() || '';
            currentState.lyrics.generatedLyrics = domRefs.generatedLyricsOutput?.value || ''; 
            currentState.style.detailedVocalRequests = domRefs.styleDetailedRequestsInput?.value.trim() || '';
            currentState.style.artistInputValue = domRefs.styleArtistInput?.value.trim() || ''; 
            currentState.style.negativePromptsValue = domRefs.styleNegativePromptsInput?.value.trim() || ''; 
            currentState.style.bpmInputValue = domRefs.styleBpmInput?.value || ''; 
            currentState.style.generatedStyleDescription = domRefs.generatedStyleOutput?.value || ''; 
            currentState.style.artist = currentState.style.artistInputValue;
            currentState.style.negativePrompts = currentState.style.negativePromptsValue;
            const bpmVal = parseInt(currentState.style.bpmInputValue, 10);
            currentState.style.bpm = !isNaN(bpmVal) ? bpmVal : null;
            return currentState;
        }

        function saveState(actionSource = "unknown") {
            if (isProcessingUndo) return;
            const currentState = getCurrentAppStateForSave();
            if (!currentState) return;
            currentState.actionSource = actionSource; 
            if (history.length > 0) {
                const lastState = { ...history[history.length - 1] };
                const currentStateForCompare = { ...currentState };
                delete lastState.actionSource; delete currentStateForCompare.actionSource;
                if (JSON.stringify(currentStateForCompare) === JSON.stringify(lastState)) return;
            }
            history.push(currentState);
            if (history.length > 25) history.shift(); 
            if (domRefs.undoButton) domRefs.undoButton.disabled = history.length <= 1;
        }

        // Modified createButton to use smaller fonts for options panel
        function createButton(text, appStatePath, category, value = text, isMultiSelect = false) {
            const button = document.createElement('button');
            button.textContent = text;
            button.dataset.appstatePath = appStatePath; button.dataset.category = category; button.dataset.value = value; 
            button.dataset.isMultiSelect = String(isMultiSelect);
            // Reduced font size and padding for buttons in options panel
            let baseClasses = 'px-2 py-1 text-xs border rounded shadow-sm transition-all duration-150 ease-in-out focus:outline-none focus:ring-1 focus:ring-opacity-50';
            let typeClasses = isMultiSelect ? 'btn-multi-select border-slate-600 hover:bg-slate-500/80 focus:ring-violet-500' : 'btn-single-select border-slate-600 hover:bg-slate-500/80 focus:ring-indigo-500';
            if (category === 'timeSignature') baseClasses = 'px-1.5 py-0.5 text-xxs border rounded-full shadow-sm transition-all min-w-[40px] text-center focus:outline-none focus:ring-1 focus:ring-opacity-50';
            
            button.className = `${baseClasses} ${typeClasses} bg-slate-700/70 text-slate-200`;
            if (category === 'songFormElement') {
                button.dataset.element = value; 
                button.addEventListener('click', handleLyricsSongFormElementClick);
            } else {
                button.addEventListener('click', handleOptionClick);
            }
            return button;
        }


        function handleOptionClick(event) {
            if (isProcessingUndo) return;
            const button = event.target.closest('button'); if (!button) return;
            const appStatePath = button.dataset.appstatePath; const value = button.dataset.value; 
            const isMultiSelect = button.dataset.isMultiSelect === 'true'; let stateChanged = false;
            let targetStatePart; let actualCategory; 
            if (appStatePath === 'unified.moodSelection') {
                targetStatePart = appState; actualCategory = 'unifiedMoodSelection';
                if (!appState.unifiedMoodSelection) appState.unifiedMoodSelection = [];
            } else {
                const pathParts = appStatePath.split('.'); 
                targetStatePart = appState[pathParts[0]]; actualCategory = pathParts[1];
            }
            if (!targetStatePart || !targetStatePart.hasOwnProperty(actualCategory)) { console.warn("Target state part or category not found for path:", appStatePath); return; }
            const selectionArray = (appStatePath === 'unified.moodSelection') ? appState.unifiedMoodSelection : targetStatePart[actualCategory];
            if (isMultiSelect) {
                if (!Array.isArray(selectionArray)) {
                    if (appStatePath === 'unified.moodSelection') appState.unifiedMoodSelection = []; else targetStatePart[actualCategory] = [];
                }
                const currentSelection = (appStatePath === 'unified.moodSelection') ? appState.unifiedMoodSelection : targetStatePart[actualCategory];
                const wasSelected = button.classList.contains('selected'); button.classList.toggle('selected');
                if (wasSelected) { 
                    button.classList.remove(isMultiSelect ? 'bg-violet-500' : 'bg-indigo-500', 'text-white'); button.classList.add('bg-slate-700/70', 'text-slate-200');
                    const index = currentSelection.indexOf(value); if (index > -1) { currentSelection.splice(index, 1); stateChanged = true; }
                } else { 
                    button.classList.add(isMultiSelect ? 'bg-violet-500' : 'bg-indigo-500', 'text-white'); button.classList.remove('bg-slate-700/70', 'text-slate-200');
                    if (!currentSelection.includes(value)) { currentSelection.push(value); stateChanged = true; }
                }
            } else { 
                const container = button.closest('.options-group, .input-container'); const alreadySelected = button.classList.contains('selected');
                if (container) { 
                    container.querySelectorAll(`button[data-appstate-path="${appStatePath}"].selected`).forEach(sibling => {
                        if (sibling !== button) { sibling.classList.remove('selected', 'bg-indigo-500', 'text-white'); sibling.classList.add('bg-slate-700/70', 'text-slate-200'); }
                    });
                }
                if (alreadySelected) { 
                    button.classList.remove('selected', 'bg-indigo-500', 'text-white'); button.classList.add('bg-slate-700/70', 'text-slate-200');
                    if (targetStatePart[actualCategory] !== null) { targetStatePart[actualCategory] = null; stateChanged = true;
                        if (appStatePath === 'style.tempo') { appState.style.bpm = null; if (domRefs.styleBpmInput) domRefs.styleBpmInput.value = ''; appState.style.bpmInputValue = ''; }
                    }
                } else { 
                    button.classList.add('selected', 'bg-indigo-500', 'text-white'); button.classList.remove('bg-slate-700/70', 'text-slate-200');
                    if (targetStatePart[actualCategory] !== value) { targetStatePart[actualCategory] = value; stateChanged = true;
                        if (appStatePath === 'style.tempo') { appState.style.bpm = null; if (domRefs.styleBpmInput) domRefs.styleBpmInput.value = ''; appState.style.bpmInputValue = ''; }
                    }
                }
            }
            if (stateChanged) { generateLlmInstructionPrompt(); saveState(`click-${appStatePath}-${getEnglishPart(value) || value}`); }
        }

        function handleLyricsSongFormElementClick(event) {
            if (isProcessingUndo) return; const button = event.target.closest('button'); if (!button) return;
            const element = button.dataset.element; 
            if (element) {
                if (!Array.isArray(appState.lyrics.selectedSongForm)) appState.lyrics.selectedSongForm = [];
                appState.lyrics.selectedSongForm.push(element); renderLyricsSelectedSongform(); generateLlmInstructionPrompt(); saveState(`addSF-${element}`);
            }
        }
        function handleSongFormRemoveLast() {
            if (isProcessingUndo) return; if (appState.lyrics.selectedSongForm.length > 0) {
                const removedElement = appState.lyrics.selectedSongForm.pop(); renderLyricsSelectedSongform(); generateLlmInstructionPrompt(); saveState(`removeLastSF-${removedElement}`);
            }
        }
        function handleSongFormClearAll() {
            if (isProcessingUndo) return; if (appState.lyrics.selectedSongForm.length > 0) {
                appState.lyrics.selectedSongForm = []; renderLyricsSelectedSongform(); generateLlmInstructionPrompt(); saveState('clearAllSF');
            }
        }

        function handleTextInputChange(event) {
            if (isProcessingUndo) return; const inputElement = event.target; const value = inputElement.value; const id = inputElement.id; let stateChanged = false;
            if (id === 'unified-mood-input') { if (appState.unifiedMoodInput !== value.trim()) { appState.unifiedMoodInput = value.trim(); stateChanged = true; } }
            else if (id === 'lyrics-story-persona-input') { if (appState.lyrics.storyPersonaInput !== value.trim()) { appState.lyrics.storyPersonaInput = value.trim(); stateChanged = true; } }
            else if (id === 'lyrics-imagery-input') { if (appState.lyrics.imageryInput !== value.trim()) { appState.lyrics.imageryInput = value.trim(); stateChanged = true; } }
            else if (id === 'lyrics-message-input') { if (appState.lyrics.messageInput !== value.trim()) { appState.lyrics.messageInput = value.trim(); stateChanged = true; } }
            else if (id === 'lyrics-reference-song-input') { if (appState.lyrics.referenceSongInput !== value.trim()) { appState.lyrics.referenceSongInput = value.trim(); stateChanged = true; } }
            else if (id === 'style-detailed-requests-input') { if (appState.style.detailedVocalRequests !== value.trim()) { appState.style.detailedVocalRequests = value.trim(); stateChanged = true; } }
            else if (id === 'style-artist-input') { if (appState.style.artistInputValue !== value) { appState.style.artistInputValue = value; appState.style.artist = value.trim(); stateChanged = true;}}
            else if (id === 'style-negative-prompts-input') { if (appState.style.negativePromptsValue !== value) { appState.style.negativePromptsValue = value; appState.style.negativePrompts = value.trim(); stateChanged = true;}}
            else if (id === 'generated-lyrics-output') { if(appState.lyrics.generatedLyrics !== value) { appState.lyrics.generatedLyrics = value; stateChanged = true; }} 
            else if (id === 'generated-style-output') { if(appState.style.generatedStyleDescription !== value) { appState.style.generatedStyleDescription = value; stateChanged = true; }} 
            if (stateChanged) { 
                if (id !== 'generated-lyrics-output' && id !== 'generated-style-output') { 
                    generateLlmInstructionPrompt(); 
                }
                if (event.type === 'change') saveState(`text-${id}`); 
            }
        }

        function handleStyleBpmInput(event) {
            if (isProcessingUndo) return; const inputElement = event.target; const rawValue = inputElement.value;
            const numericValue = rawValue ? parseInt(rawValue, 10) : null; let stateChanged = false;
            appState.style.bpmInputValue = rawValue; 
            if (numericValue !== null && !isNaN(numericValue) && numericValue >= 30 && numericValue <= 300) {
                if (appState.style.bpm !== numericValue) {
                    appState.style.bpm = numericValue; stateChanged = true;
                    if (appState.style.tempo !== null) {
                        appState.style.tempo = null;
                        if (domRefs.styleTempoButtonsGroup) {
                            domRefs.styleTempoButtonsGroup.querySelectorAll('button.selected').forEach(b => { b.classList.remove('selected', 'bg-indigo-500', 'text-white'); b.classList.add('bg-slate-700/70', 'text-slate-200'); });
                        }
                    }
                }
            } else { if (appState.style.bpm !== null) { appState.style.bpm = null; stateChanged = true; } }
            if (stateChanged) { generateLlmInstructionPrompt(); if (event.type === 'change') saveState('style-bpm-input'); }
        }

        function renderLyricsSelectedSongform() {
            if (!domRefs.lyricsSelectedSongformContainer) return; domRefs.lyricsSelectedSongformContainer.innerHTML = ''; 
            const formElements = appState.lyrics.selectedSongForm;
            if (!formElements || formElements.length === 0) { domRefs.lyricsSelectedSongformContainer.innerHTML = `<span class="placeholder-text-custom text-xxs">Click elements above...</span>`; return; }
            formElements.forEach(element => {
                if (element && element.startsWith('[') && element.endsWith(']')) {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'sequence-tag songform-tag bg-purple-600 text-white px-1.5 py-0.5 text-xxs rounded-full inline-flex items-center';
                    tagSpan.textContent = element; domRefs.lyricsSelectedSongformContainer.appendChild(tagSpan);
                }
            });
        }

        function generateLlmInstructionPrompt() {
            const { lyrics, style, unifiedMoodSelection, unifiedMoodInput } = appState;
            let llmRole = "당신은 뛰어난 작사가이자 창의적인 음악 프로듀서 AI입니다.";
            if (lyrics.theme === '광고') llmRole = "당신은 CM송 전문 작사가 겸 음악 컨셉터입니다.";
            else if (lyrics.theme === '찬양') llmRole = "당신은 깊은 영성을 담아내는 CCM 작사가 겸 음악 프로듀서입니다.";
            let prompt = `${llmRole}\n\n`;
            prompt += `주어진 모든 사용자 선택 정보와 아래의 상세 지침에 따라 다음 두 가지 핵심 작업을 수행해 주십시오:\n\n`;
            prompt += `1. **한글 가사 생성**:\n`;
            prompt += `   1. AI 역할 수행: 제시된 '${llmRole}'과 모든 '[사용자 선택 정보]'에 완전히 몰입하여 작업합니다.\n`;
            prompt += `   2. 정보 종합 및 분석: ‘주제’, '[사용자 선택 정보]'의 '가사 관련 핵심 내용' (특히 '참고 곡 제목'이 있다면 해당 곡의 가사 스타일 포함)과 '음악 스타일 관련 특징' 모두를 유기적으로 연결하고 종합 분석하여 가사 내용, 표현, 음절, 운율, 글자 수를 잘 고려해서 가사를 생성합니다. 읽기 쉽고 발음하기 편하게 말 하는 듯한 가사로 만듭니다. 표현된 가사들의 스토리와 감정의 표현은 전체적인 가사 내용의 맥락과 표현 방식 및 분위기를 아주 적절하게 반영합니다.\n`; 
            prompt += `   3. 가사의 문장은 억지 스럽지 않고 전후 상황과 주제 및 소 주제의 맥락이 이야기 하 듯 자연스럽게 연결 되도록 합니다.\n`;
            prompt += `   4. 창의적 가사: 2020년 이후 한국 문학의 특징(예: 개인의 내면과 일상에 대한 섬세한 시선, 모호하고 중의적인 표현, 파편화된 감정과 서사, 도시적 감수성, 사회적 이슈의 은유적 반영 등)을 가미하여 창의적이고 깊이 있는 가사를 작성합니다. **만약 '참고 곡 제목'이 제공되었다면, 해당 곡의 독특한 가사 스타일(어휘, 문체, 감성 표현 등)을 분석하여 새로운 가사에 창의적으로 접목시켜 주십시오.**\n`; 
            prompt += `   5. 구조 및 형식: 요청된 '[사용자 선택 정보]'의 '송폼 구조'가 있다면 따르고, 없다면 일반적인 대중음악 구조를 따릅니다. 모든 비-가사 지시사항은 반드시 대괄호 [ ] 안에 영문으로 작성합니다.\n`;
            prompt += `   6. [Intro] 와 [Outro] 에는 특별한 경우를 제외하고 가급적 가사를 만들지 않습니다. 가사의 한 줄은 일반적으로 두 마디 분량으로 생각하고, **특히 [Chorus] 부분은 반드시 4줄로 구성해주십시오.** 다른 섹션(예: [Verse])도 가급적 4줄 단위로 작성하는 것을 권장합니다.\n`;
            prompt += `   7. 표현 및 완성도: 상투적인 표현과 진부함을 피하고, 선택된 '[사용자 선택 정보]'의 '언어적 톤'과 '분위기'를 반영한 참신한 표현을 사용합니다. 메시지가 명확하면서도 예술적으로 전달되도록 합니다.\n`;
            prompt += `   8. 음악성 고려: '[사용자 선택 정보]'의 '음악 스타일 관련 특징' (장르, 박자, 템포 등)을 참고하여 음절 수와 글자 수를 자연스럽게 조절합니다.\n`;
            prompt += `   9. 라임 : 필요한 경우 내용적인 라임, 발음 상의 라임, 단어 상의 라임을 맞춰 주세요.\n\n`;
            let styleDescriptionParts = [];
            if (style.eraFeatures.length > 0) styleDescriptionParts.push(style.eraFeatures.map(e => getEnglishPart(e) || e).join(', '));
            if (style.genres.length > 0) styleDescriptionParts.push(style.genres.map(g => getEnglishPart(g) || g).join(', '));
            let timeTempo = [];
            if (style.timeSignature) timeTempo.push(getEnglishPart(style.timeSignature) || style.timeSignature);
            if (style.tempo) timeTempo.push(getEnglishPart(style.tempo) || style.tempo);
            if (style.bpm) timeTempo.push(`${style.bpm} BPM`);
            if (timeTempo.length > 0) styleDescriptionParts.push(timeTempo.join(', '));
            let moodVibeForStyle = [];
            if (unifiedMoodSelection.length > 0) moodVibeForStyle = moodVibeForStyle.concat(unifiedMoodSelection.map(m => getEnglishPart(m) || m));
            if (unifiedMoodInput) { const moodKeywords = unifiedMoodInput.split(/[\s,]+/).filter(w => /^[a-zA-Z]+$/.test(w)).slice(0,3); if (moodKeywords.length > 0) moodVibeForStyle = moodVibeForStyle.concat(moodKeywords); }
            if (moodVibeForStyle.length > 0) styleDescriptionParts.push([...new Set(moodVibeForStyle)].join(', '));
            if (style.instruments.length > 0) styleDescriptionParts.push(`featuring ${style.instruments.map(i => getEnglishPart(i) || i).join(', ')}`);
            let vocalDetailsArray = []; const getEnglishArray = (arr) => arr.map(item => getEnglishPart(item)).filter(part => part);
            if (style.vocals && style.vocals.length > 0) { vocalDetailsArray = vocalDetailsArray.concat(getEnglishArray(style.vocals)); }
            if (style.vocalAge) { const agePart = getEnglishPart(style.vocalAge) || style.vocalAge; const ageText = `${agePart} age`; let mainVocalIdx = vocalDetailsArray.findIndex(v => v.toLowerCase().includes("male vocal") || v.toLowerCase().includes("female vocal") || v.toLowerCase().includes("child vocal")); if (mainVocalIdx !== -1 && vocalDetailsArray[mainVocalIdx]) { vocalDetailsArray[mainVocalIdx] += ` (${ageText})`; } else { if (!vocalDetailsArray.some(el => el.includes(agePart))) { vocalDetailsArray.push(`${ageText} vocal`); } } }
            if (style.vocalTones && style.vocalTones.length > 0) { getEnglishArray(style.vocalTones).forEach(tone => { vocalDetailsArray.push(`${tone} vocal tone`); }); }
            if (vocalDetailsArray.length > 0) styleDescriptionParts.push([...new Set(vocalDetailsArray)].join(', '));
            if (style.artist) styleDescriptionParts.push(`in the style of ${style.artist}`);
            let finalStyleDescription = styleDescriptionParts.filter(p => p.trim() !== '').join('. ');
            if (style.negativePrompts) finalStyleDescription += (finalStyleDescription ? ". " : "") + `Exclude: ${style.negativePrompts}.`;
            prompt += `2.  **영문 SUNO 스타일 설명 생성 (500자 이내)**:\n`;
            prompt += `    * 아래 '[사용자 선택 정보]'의 **'음악 스타일 관련 특징' 섹션에 명시된 모든 음악적 요소들(장르, 박자, 템포, 시대/사운드 특징, 주요 악기, 보컬 스타일/연령/톤, 상세 요청사항, 참고 아티스트 스타일, 제외할 요소 등)과 '선택된 분위기/감성 키워드'만을 종합적으로 반영하여**, SUNO AI v4.5 모델에 입력하기 적합한 상세하고 서술적인 '스타일 설명(Style Description)'을 **영문으로 작성**해 주십시오. **가사 내용, 이야기/상황, 메시지, 참고 곡 제목 등 가사 관련 정보는 이 스타일 설명에 포함하지 마십시오.**\n`; 
            prompt += `    * 이 설명은 다음 순서를 참고하여 자연스러운 문장으로 구성해주십시오: **시대적 특성, 장르, 박자 및 템포, 곡의 전반적인 분위기, 주요 악기, 보컬 특징, 참고 아티스트 스타일 순**으로 관련 정보를 포함하고, 사용자의 '상세 요청사항(한글)'의 의미를 파악하여 영문 스타일에 창의적으로 반영해야 합니다. '제외할 요소'도 명시하십시오.\n`;
            prompt += `    * 이 영문 스타일 설명은 단순한 키워드 나열이 아니라, 곡의 전체적인 느낌, 주요 악기의 사용 방식, 곡의 전개 방식 등을 포함해야 합니다. **반드시 500자 이내로 간결하게 작성**해주십시오.\n\n`;
            prompt += `결과물은 아래와 같이 명확히 구분하여 제공해 주십시오:\n\n`;
            prompt += `## 가사(Lyrics)\n(여기에 생성된 한글 가사)\n\n`;
            prompt += `## 스타일 설명(Style Description)\n${finalStyleDescription || '(스타일 관련 선택/입력 사항을 바탕으로 여기에 영문 스타일 설명을 생성해주세요.)'}\n\n`; 
            prompt += `--- --- ---\n**[사용자 선택 정보 (AI 참고 정보)]:**\n\n`;
            let metaGenre = lyrics.theme ? (lyrics.theme === '광고' ? 'Commercial Song' : (lyrics.theme === '찬양' ? 'Gospel' : getEnglishPart(lyrics.theme))) : 'Music';
            if (style.genres.length > 0) { metaGenre = style.genres.map(g => getEnglishPart(g) || g).join('/'); }
            let metaMood = unifiedMoodSelection.length > 0 ? unifiedMoodSelection.map(m => getEnglishPart(m) || m).join(', ') : metaGenre;
            if (unifiedMoodInput) { const moodKeywords = unifiedMoodInput.split(' ').filter(w => /[a-zA-Z]/.test(w)).slice(0,3).join(' '); if (moodKeywords) metaMood += (metaMood ? ", " : "") + moodKeywords; }
            prompt += `* **[메타데이터 참고]:** [Metadata: Genre: ${metaGenre}, Mood: ${metaMood}]\n\n`;
            prompt += `* **핵심 아이디어 & 분위기 (가사 및 스타일 참고):**\n`;
            prompt += `    * 테마 (한글): ${lyrics.theme || '(선택 안 함)'}\n`;
            prompt += `    * 선택된 분위기/감성 키워드 (영문 참고용): ${unifiedMoodSelection.length > 0 ? unifiedMoodSelection.map(m => getEnglishPart(m) || m).join(', ') : '(선택 안 함)'}\n`;
            prompt += `    * 분위기/감성 상세 묘사 (한글): ${unifiedMoodInput || '(입력 안 함)'}\n`;
            prompt += `* **가사 내용 & 구조 (가사 생성 시 핵심 참고):**\n`;
            prompt += `    * 이야기/상황/화자 (한글): ${lyrics.storyPersonaInput || '(입력 안 함)'}\n`;
            prompt += `    * 주요 이미지/키워드 (한글): ${lyrics.imageryInput || '(입력 안 함)'}\n`;
            prompt += `    * 전달 메시지/대상 (한글): ${lyrics.messageInput || '(입력 안 함)'}\n`;
            prompt += `    * 언어적 톤 (한글): ${lyrics.tone.length > 0 ? lyrics.tone.map(t => getKoreanPart(t) || t).join(', ') : '(선택 안 함)'}\n`;
            prompt += `    * 참고 곡 제목 (가사 스타일 참고용): ${lyrics.referenceSongInput || '(입력 안 함)'}\n`; 
            prompt += `    * 요청된 송폼 구조 (영문): ${lyrics.selectedSongForm.length > 0 ? lyrics.selectedSongForm.join(' -> ') : '(자동 구성 요청)'}\n`;
            prompt += `* **음악 스타일 관련 특징 (영문 스타일 설명 생성 시 핵심 참고):**\n`;
            prompt += `    * 장르 (영문): ${style.genres.length > 0 ? style.genres.map(g => getEnglishPart(g) || g).join(', ') : '(LLM이 가사와 분위기에 맞춰 제안)'}\n`;
            prompt += `    * 박자 (영문): ${style.timeSignature ? (getEnglishPart(style.timeSignature) || style.timeSignature) : '(일반적 박자 또는 LLM 제안)'}\n`;
            prompt += `    * 템포/에너지 (영문): ${style.tempo ? (getEnglishPart(style.tempo) || style.tempo) : '(지정 안 함)'}`;
            if (style.bpm) prompt += ` / BPM: ${style.bpm}`; prompt += `\n`;
            prompt += `    * 시대/사운드 특징 (영문): ${style.eraFeatures.length > 0 ? style.eraFeatures.map(e => getEnglishPart(e) || e).join(', ') : '(지정 안 함)'}\n`;
            prompt += `    * 주요 악기 (영문): ${style.instruments.length > 0 ? style.instruments.map(i => getEnglishPart(i) || i).join(', ') : '(LLM이 장르와 분위기에 맞춰 제안)'}\n`;
            prompt += `    * 보컬 스타일/연령/톤 (영문): ${vocalDetailsArray.length > 0 ? [...new Set(vocalDetailsArray)].join(', ') : '(LLM이 곡의 분위기에 맞춰 제안)'}\n`;
            prompt += `    * 상세 요청사항 (한글, 영문 스타일에 반영 필요): ${style.detailedVocalRequests || '(없음)'}\n`;
            prompt += `    * 참고 아티스트 스타일 (영문 - 음악 스타일 참고용): ${style.artist || '(없음)'}\n`; 
            prompt += `    * 스타일에서 제외할 요소 (영문): ${style.negativePrompts || '(없음)'}\n`;
            prompt += `--- --- ---`;
            let hasContent = false;
            if (lyrics.theme || unifiedMoodInput || lyrics.storyPersonaInput || lyrics.referenceSongInput || style.genres.length > 0 || style.detailedVocalRequests) hasContent = true;
            if (!hasContent && unifiedMoodSelection.length === 0 && lyrics.tone.length === 0 && lyrics.selectedSongForm.length === 0 && style.instruments.length === 0 && style.vocals.length === 0) {
                prompt = "LLM 지시 프롬프트를 생성하려면 다양한 옵션을 선택하거나 내용을 입력해주세요.";
            }
            if (domRefs.llmPromptOutput) domRefs.llmPromptOutput.textContent = prompt;
            const charCount = finalStyleDescription.length;
            if (domRefs.styleCharCountDisplay) {
                domRefs.styleCharCountDisplay.textContent = `Style: ${charCount} / 500 chars`;
                domRefs.styleCharCountDisplay.classList.toggle('text-red-400', charCount > 500);
                domRefs.styleCharCountDisplay.classList.toggle('text-dark-text-muted', charCount <= 500);
            }
        }

        function updateUIFromState(stateToRestore) {
            isProcessingUndo = true;
            try {
                const clonedState = deepClone(stateToRestore); if (!clonedState) { console.error("Failed to clone state."); isProcessingUndo = false; return; }
                clonedState.unifiedMoodSelection = clonedState.unifiedMoodSelection || []; clonedState.unifiedMoodInput = clonedState.unifiedMoodInput || '';
                clonedState.lyrics = clonedState.lyrics || {};
                ['theme', 'storyPersonaInput', 'imageryInput', 'messageInput', 'referenceSongInput', 'generatedLyrics'].forEach(k => clonedState.lyrics[k] = clonedState.lyrics[k] ?? (k.includes('Input') || k.includes('Lyrics') ? '' : null) );
                clonedState.lyrics.tone = clonedState.lyrics.tone || []; clonedState.lyrics.selectedSongForm = clonedState.lyrics.selectedSongForm || [];
                clonedState.style = clonedState.style || {};
                ['genres', 'instruments', 'eraFeatures', 'vocals', 'vocalTones'].forEach(k => clonedState.style[k] = clonedState.style[k] || []);
                ['timeSignature', 'tempo', 'bpm', 'vocalAge', 'detailedVocalRequests', 'artist', 'negativePrompts', 'generatedStyleDescription', 'bpmInputValue', 'artistInputValue', 'negativePromptsValue'].forEach(k => {
                    clonedState.style[k] = clonedState.style[k] ?? ((k.includes('Input') || k.includes('Value') || k.includes('Requests') || k.includes('Description') || k === 'artist' || k === 'negativePrompts') ? '' : null);
                });
                appState = clonedState; 
                if (domRefs.apiKeyInput) domRefs.apiKeyInput.value = appState.apiKey || '';
                if (domRefs.unifiedMoodInputArea) domRefs.unifiedMoodInputArea.value = appState.unifiedMoodInput || '';
                if (domRefs.lyricsStoryPersonaInput) domRefs.lyricsStoryPersonaInput.value = appState.lyrics.storyPersonaInput || '';
                if (domRefs.lyricsImageryInput) domRefs.lyricsImageryInput.value = appState.lyrics.imageryInput || '';
                if (domRefs.lyricsMessageInput) domRefs.lyricsMessageInput.value = appState.lyrics.messageInput || '';
                if (domRefs.lyricsReferenceSongInput) domRefs.lyricsReferenceSongInput.value = appState.lyrics.referenceSongInput || '';
                if (domRefs.generatedLyricsOutput) domRefs.generatedLyricsOutput.value = appState.lyrics.generatedLyrics || '';
                if (domRefs.styleDetailedRequestsInput) domRefs.styleDetailedRequestsInput.value = appState.style.detailedVocalRequests || '';
                if (domRefs.styleArtistInput) domRefs.styleArtistInput.value = appState.style.artistInputValue ?? appState.style.artist ?? '';
                if (domRefs.styleNegativePromptsInput) domRefs.styleNegativePromptsInput.value = appState.style.negativePromptsValue ?? appState.style.negativePrompts ?? '';
                if (domRefs.generatedStyleOutput) domRefs.generatedStyleOutput.value = appState.style.generatedStyleDescription || '';
                if (domRefs.styleBpmInput) domRefs.styleBpmInput.value = appState.style.bpmInputValue ?? (appState.style.bpm !== null && !isNaN(appState.style.bpm) ? String(appState.style.bpm) : '');
                document.querySelectorAll('.options-column button.selected[data-appstate-path]').forEach(b => { b.classList.remove('selected', 'bg-indigo-500', 'bg-violet-500', 'text-white'); b.classList.add('bg-slate-700/70', 'text-slate-200'); });
                const sectionsToUpdate = {
                    'lyrics.theme': { container: domRefs.lyricsMainThemeGroup, multi: false }, 'lyrics.tone': { container: domRefs.lyricsToneOptions, multi: true },
                    'style.genres': { container: domRefs.styleGenreOptions, multi: true }, 'style.timeSignature': { container: domRefs.styleTimeSignatureOptions, multi: false },
                    'style.tempo': { container: domRefs.styleTempoButtonsGroup, multi: false }, 'style.eraFeatures': { container: [domRefs.styleEraOptionsEra, domRefs.styleEraOptionsFeatures], multi: true },
                    'style.instruments': { container: domRefs.styleInstrumentOptions, multi: true }, 'style.vocals': { container: domRefs.styleVocalOptions, multi: true },
                    'style.vocalAge': { container: domRefs.styleVocalAgeOptions, multi: false }, 'style.vocalTones': { container: domRefs.styleToneOptions, multi: true }, 
                    'unified.moodSelection': { container: domRefs.unifiedMoodOptionsContainer, multi: true } 
                };
                for (const path in sectionsToUpdate) {
                    const config = sectionsToUpdate[path]; let valueOrValues;
                    if (path === 'unified.moodSelection') valueOrValues = appState.unifiedMoodSelection;
                    else { const pathParts = path.split('.'); const stateObject = appState[pathParts[0]]; const categoryKey = pathParts[1]; valueOrValues = stateObject ? stateObject[categoryKey] : null; }
                    const containers = Array.isArray(config.container) ? config.container : [config.container]; const selectedBgClass = config.multi ? 'bg-violet-500' : 'bg-indigo-500';
                    containers.forEach(container => {
                        if (container && valueOrValues !== null && valueOrValues !== undefined) {
                            if (Array.isArray(valueOrValues)) { valueOrValues.forEach(val => { try { const button = container.querySelector(`button[data-value="${CSS.escape(String(val))}"]`); if (button) { button.classList.add('selected', selectedBgClass, 'text-white'); button.classList.remove('bg-slate-700/70', 'text-slate-200'); } } catch (e) {} });
                            } else { try { const button = container.querySelector(`button[data-value="${CSS.escape(String(valueOrValues))}"]`); if (button) { button.classList.add('selected', selectedBgClass, 'text-white'); button.classList.remove('bg-slate-700/70', 'text-slate-200'); } } catch (e) {} }
                        }
                    });
                }
                renderLyricsSelectedSongform(); generateLlmInstructionPrompt(); 
            } catch (error) { console.error("Error during UI restoration:", error); } 
            finally { setTimeout(() => { isProcessingUndo = false; if (domRefs.undoButton) domRefs.undoButton.disabled = history.length <= 1; }, 50); }
        }

        function savePresetToFile() {
            if (!domRefs.presetNameInput) return; let filename = domRefs.presetNameInput.value.trim();
            if (!filename) { const themePart = appState.lyrics.theme ? getEnglishPart(appState.lyrics.theme).replace(/\s+/g, '_') : 'Untitled'; const moodPart = appState.unifiedMoodSelection.length > 0 ? getEnglishPart(appState.unifiedMoodSelection[0]).replace(/\s+/g, '_') : (appState.unifiedMoodInput ? appState.unifiedMoodInput.split(' ')[0].replace(/\s+/g, '_') : 'Preset'); filename = `${themePart}_${moodPart}_${new Date().toISOString().slice(0,10)}`; domRefs.presetNameInput.value = filename; }
            if (!filename.toLowerCase().endsWith('.json')) filename += '.json';
            const stateToSave = getCurrentAppStateForSave(); if (!stateToSave) { alert("Failed to get current state."); return; }
            try {
                const jsonString = JSON.stringify(stateToSave, null, 2); const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                alert(`Preset saved as '${filename}'.`);
            } catch (e) { console.error("Error creating preset file:", e); alert("Error saving preset."); }
        }

        function triggerLoadPresetFromFile() { if (domRefs.loadPresetFileInput) { domRefs.loadPresetFileInput.value = null; domRefs.loadPresetFileInput.click(); } else { alert("Error: File input not found."); } }
        function handlePresetFileLoad(event) {
            const file = event.target.files ? event.target.files[0] : null; if (!file) return;
            if (file.type && file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) { alert(`Invalid file type. Please select '.json'.`); return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                try {
                    const loadedState = JSON.parse(fileContent);
                    if (loadedState && typeof loadedState === 'object' && loadedState.lyrics && loadedState.style) {
                        saveState(`Before Load: ${file.name}`); updateUIFromState(loadedState); alert(`Preset '${file.name}' loaded.`);
                        if (domRefs.presetNameInput) domRefs.presetNameInput.value = file.name.replace(/\.json$/i, '');
                    } else alert(`Error: Invalid preset file format.`);
                } catch (error) { console.error("Error parsing preset:", error); alert(`Error parsing preset file.`); }
            };
            reader.onerror = function(e) { alert(`Error reading file.`); }; reader.readAsText(file);
        }

        function copyToClipboard(elementOrText, buttonToUpdate, defaultButtonText, isText=false) {
            const textToCopy = isText ? elementOrText : (elementOrText ? elementOrText.textContent : '');
            const placeholderLlm = "LLM 지시 프롬프트를 생성하려면 다양한 옵션을 선택하거나 내용을 입력해주세요.";
            const successText = '복사 완료!'; const nothingToCopyMsg = '복사할 내용이 없습니다.';
            if (!textToCopy || textToCopy.trim() === '' || (!isText && textToCopy === placeholderLlm) ) { alert(nothingToCopyMsg); return; }
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => { if(buttonToUpdate) {buttonToUpdate.innerHTML = `<i class="fas fa-check mr-1"></i> ${successText}`; buttonToUpdate.disabled = true; setTimeout(() => { buttonToUpdate.innerHTML = `<i class="fas fa-copy mr-1"></i> ${defaultButtonText}`; buttonToUpdate.disabled = false; }, 1500);}})
                    .catch(err => { alert('클립보드 복사 실패.'); });
            } else { 
                try {
                    const textArea = document.createElement("textarea"); textArea.value = textToCopy; textArea.style.position="fixed"; textArea.style.opacity="0"; document.body.appendChild(textArea);
                    textArea.focus(); textArea.select(); document.execCommand('copy'); document.body.removeChild(textArea);
                    if(buttonToUpdate) { buttonToUpdate.innerHTML = `<i class="fas fa-check mr-1"></i> ${successText}`; buttonToUpdate.disabled = true; setTimeout(() => { buttonToUpdate.innerHTML = `<i class="fas fa-copy mr-1"></i> ${defaultButtonText}`; buttonToUpdate.disabled = false; }, 1500);}
                } catch (err) { alert('클립보드 복사 실패.'); }
            }
        }

        async function callGeminiApi() {
            const apiKey = appState.apiKey || domRefs.apiKeyInput.value;
            if (!apiKey) { alert("Please enter your Gemini API Key in the header."); domRefs.apiKeyInput.focus(); return; }
            const llmPrompt = domRefs.llmPromptOutput.textContent;
            if (!llmPrompt || llmPrompt.includes("Select options to generate")) { alert("Please generate an LLM instruction prompt first."); return; }
            if (domRefs.apiLoadingOverlay) domRefs.apiLoadingOverlay.classList.remove('hidden');
            try {
                const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const requestBody = { contents: [{ parts: [{ text: llmPrompt }] }] };
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                if (!response.ok) { const errorData = await response.json(); console.error("API Error Response:", errorData); throw new Error(`API request failed: ${errorData.error?.message || response.statusText}`); }
                const data = await response.json();
                let generatedText = "";
                if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) {
                    generatedText = data.candidates[0].content.parts[0].text;
                } else { console.warn("Could not extract text from API response:", data); generatedText = "Could not parse content from API response."; }
                const lyricsMatch = generatedText.match(/## 가사\(Lyrics\)\s*([\s\S]*?)(?=\n## 스타일 설명\(Style Description\)|$)/i);
                const styleMatch = generatedText.match(/## 스타일 설명\(Style Description\)\s*([\s\S]*?)(?=\n--- --- ---|$)/i);
                appState.lyrics.generatedLyrics = lyricsMatch ? lyricsMatch[1].trim() : "Could not parse lyrics.";
                appState.style.generatedStyleDescription = styleMatch ? styleMatch[1].trim() : "Could not parse style description.";
                if(domRefs.generatedLyricsOutput) domRefs.generatedLyricsOutput.value = appState.lyrics.generatedLyrics;
                if(domRefs.generatedStyleOutput) domRefs.generatedStyleOutput.value = appState.style.generatedStyleDescription;
                alert("Content generated successfully!"); saveState('api-generation-success');
            } catch (error) { console.error("Error calling Gemini API:", error); alert(`Error during API call: ${error.message}`); if(domRefs.generatedLyricsOutput) domRefs.generatedLyricsOutput.value = `API Error: ${error.message}`; if(domRefs.generatedStyleOutput) domRefs.generatedStyleOutput.value = ""; } 
            finally { if (domRefs.apiLoadingOverlay) domRefs.apiLoadingOverlay.classList.add('hidden'); }
        }

        function initialize() {
            console.log("Initializing LLM Prompt Generator (v3.0.6 - Major Layout & Font Adjustments)...");
            try {
                const storedApiKey = localStorage.getItem(GEMINI_API_KEY_STORAGE_KEY);
                if (storedApiKey) { appState.apiKey = storedApiKey; if (domRefs.apiKeyInput) domRefs.apiKeyInput.value = storedApiKey; }
                Object.keys(lyricsData.themes).forEach(cat => { if (Array.isArray(lyricsData.themes[cat])) lyricsData.themes[cat].sort(sortByKorean); });
                styleData.instruments.sort(sortByEnglish); lyricsData.tones.sort(sortByKorean); styleData.moods.sort(sortByKorean); 
                styleData.genres.sort(sortByEnglish); styleData.tempos.sort(sortByEnglish); styleData.vocalTones.sort(sortByKorean); 
                styleData.eraFeatures.sort(sortByEnglish); styleData.vocals.sort(sortByEnglish); styleData.vocalAges.sort(sortByEnglish);
                if (domRefs.lyricsMainThemeGroup) Object.keys(lyricsData.themes).sort(sortByKorean).forEach(th => domRefs.lyricsMainThemeGroup.appendChild(createButton(th, 'lyrics.theme', 'theme', th, false)));
                if (domRefs.unifiedMoodOptionsContainer) styleData.moods.forEach(item => domRefs.unifiedMoodOptionsContainer.appendChild(createButton(item, 'unified.moodSelection', unifiedMoodCategory, item, true)));
                if (domRefs.lyricsToneOptions) lyricsData.tones.forEach(toneValue => domRefs.lyricsToneOptions.appendChild(createButton(toneValue, 'lyrics.tone', 'tone', toneValue, true)));
                if (domRefs.lyricsSongformElementsContainer) lyricsData.songFormElements.forEach(el => domRefs.lyricsSongformElementsContainer.appendChild(createButton(el, 'lyrics.selectedSongForm', 'songFormElement', el)));
                if (domRefs.styleGenreOptions) styleData.genres.forEach(item => domRefs.styleGenreOptions.appendChild(createButton(item, 'style.genres', 'genres', item, true)));
                if (domRefs.styleTimeSignatureOptions) styleData.timeSignatures.forEach(item => domRefs.styleTimeSignatureOptions.appendChild(createButton(item, 'style.timeSignature', 'timeSignature', item, false)));
                if (domRefs.styleInstrumentOptions) styleData.instruments.forEach(item => domRefs.styleInstrumentOptions.appendChild(createButton(item, 'style.instruments', 'instruments', item, true)));
                if (domRefs.styleTempoButtonsGroup) styleData.tempos.forEach(item => domRefs.styleTempoButtonsGroup.appendChild(createButton(item, 'style.tempo', 'tempo', item, false)));
                const eraRegex = /\d{2}s|Modern|Futuristic|Pre-50s/i; 
                const eras = styleData.eraFeatures.filter(item => eraRegex.test(getEnglishPart(item))).sort(sortByEnglish);
                const features = styleData.eraFeatures.filter(item => !eraRegex.test(getEnglishPart(item))).sort(sortByEnglish);
                if (domRefs.styleEraOptionsEra) eras.forEach(item => domRefs.styleEraOptionsEra.appendChild(createButton(item, 'style.eraFeatures', 'eraFeatures', item, true)));
                if (domRefs.styleEraOptionsFeatures) features.forEach(item => domRefs.styleEraOptionsFeatures.appendChild(createButton(item, 'style.eraFeatures', 'eraFeatures', item, true)));
                if (domRefs.styleVocalOptions) styleData.vocals.forEach(item => domRefs.styleVocalOptions.appendChild(createButton(item, 'style.vocals', 'vocals', item, true)));
                if (domRefs.styleVocalAgeOptions) styleData.vocalAges.forEach(item => domRefs.styleVocalAgeOptions.appendChild(createButton(item, 'style.vocalAge', 'vocalAge', item, false)));
                if (domRefs.styleToneOptions) styleData.vocalTones.forEach(item => domRefs.styleToneOptions.appendChild(createButton(item, 'style.vocalTones', 'vocalTones', item, true))); 
                [domRefs.unifiedMoodInputArea, domRefs.lyricsStoryPersonaInput, domRefs.lyricsImageryInput, domRefs.lyricsMessageInput,
                 domRefs.lyricsReferenceSongInput, domRefs.styleDetailedRequestsInput, domRefs.styleArtistInput, domRefs.styleNegativePromptsInput,
                 domRefs.generatedLyricsOutput, domRefs.generatedStyleOutput
                ].forEach(inputElement => { if (inputElement) { inputElement.addEventListener('input', handleTextInputChange); inputElement.addEventListener('change', handleTextInputChange); } });
                if (domRefs.styleBpmInput) { domRefs.styleBpmInput.addEventListener('input', handleStyleBpmInput); domRefs.styleBpmInput.addEventListener('change', handleStyleBpmInput); }
                if (domRefs.saveApiKeyButton) domRefs.saveApiKeyButton.addEventListener('click', () => { const apiKeyToSave = domRefs.apiKeyInput.value; if (apiKeyToSave) { localStorage.setItem(GEMINI_API_KEY_STORAGE_KEY, apiKeyToSave); appState.apiKey = apiKeyToSave; alert("API Key saved to browser's local storage."); } else { localStorage.removeItem(GEMINI_API_KEY_STORAGE_KEY); appState.apiKey = ''; alert("API Key cleared."); } });
                if (domRefs.generateWithApiButton) domRefs.generateWithApiButton.addEventListener('click', callGeminiApi);
                if (domRefs.undoButton) domRefs.undoButton.addEventListener('click', () => { if (history.length > 1) { isProcessingUndo = true; history.pop(); const previousState = deepClone(history[history.length - 1]); if (previousState) updateUIFromState(previousState); else isProcessingUndo = false; } if (domRefs.undoButton) domRefs.undoButton.disabled = history.length <= 1; });
                if (domRefs.resetButton) domRefs.resetButton.addEventListener('click', () => {
                    if (confirm("초기화하시겠습니까? 이 작업은 되돌릴 수 없습니다.")) {
                        saveState("Before Reset"); 
                        const initialAppState = { apiKey: appState.apiKey, unifiedMoodSelection: [], unifiedMoodInput: '', lyrics: { theme: null, storyPersonaInput: '', imageryInput: '', messageInput: '', tone: [], referenceSongInput: '', selectedSongForm: [], generatedLyrics: '' }, style: { genres: [], timeSignature: null, instruments: [], tempo: null, bpm: null, eraFeatures: [], vocals: [], vocalAge: null, vocalTones: [], detailedVocalRequests: '', artist: '', negativePrompts: '', generatedStyleDescription: '', bpmInputValue: '', artistInputValue: '', negativePromptsValue: '' }, actionSource: 'reset' };
                        history = [deepClone(initialAppState)]; updateUIFromState(initialAppState); if (domRefs.undoButton) domRefs.undoButton.disabled = true;
                        alert("초기화되었습니다. (API 키는 유지됩니다)");
                    }
                });
                if (domRefs.homeButton) domRefs.homeButton.addEventListener('click', () => alert("Home (Not implemented)"));
                if(domRefs.songformRemoveLastButton) domRefs.songformRemoveLastButton.addEventListener('click', handleSongFormRemoveLast);
                if(domRefs.songformClearAllButton) domRefs.songformClearAllButton.addEventListener('click', handleSongFormClearAll);
                if (domRefs.copyLlmPromptButton) domRefs.copyLlmPromptButton.addEventListener('click', () => copyToClipboard(domRefs.llmPromptOutput, domRefs.copyLlmPromptButton, "Copy Prompt"));
                if (domRefs.copyLyricsButton) domRefs.copyLyricsButton.addEventListener('click', () => copyToClipboard(domRefs.generatedLyricsOutput.value, domRefs.copyLyricsButton, "Copy", true));
                if (domRefs.copyStyleButton) domRefs.copyStyleButton.addEventListener('click', () => copyToClipboard(domRefs.generatedStyleOutput.value, domRefs.copyStyleButton, "Copy", true));
                if (domRefs.savePresetButton) domRefs.savePresetButton.addEventListener('click', savePresetToFile);
                if (domRefs.loadPresetFileButton) domRefs.loadPresetFileButton.addEventListener('click', triggerLoadPresetFromFile);
                if (domRefs.loadPresetFileInput) domRefs.loadPresetFileInput.addEventListener('change', handlePresetFileLoad);
                renderLyricsSelectedSongform(); generateLlmInstructionPrompt(); if(domRefs.undoButton) domRefs.undoButton.disabled = true; 
                setTimeout(() => { const initialState = getCurrentAppStateForSave(); if (initialState && history.length === 0) { initialState.actionSource = "initialLoad"; history = [initialState]; if (domRefs.undoButton) domRefs.undoButton.disabled = true; } else if (history.length === 1 && history[0].actionSource === 'reset') { if (domRefs.undoButton) domRefs.undoButton.disabled = true; } }, 150);
            } catch (err) { console.error("Initialization Error:", err); if (domRefs.llmPromptOutput) domRefs.llmPromptOutput.textContent = "Error initializing. Check console."; }
            console.log("Initialization complete (v3.0.6 - Major Layout & Font Adjustments).");
        }
        initialize();
    });
</script>

</body>
</html>
